
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Bryton's Blog</title>
  <meta name="author" content="Bryton Lee">

  
  <meta name="description" content="最近在写一个nginx的模块，过程中遇到一个小问题，感受到了C语言宏跟函数的区别，记录下来。 问题现象: 先看一段相关代码 393 ngx_http_stylecombine_body_filter(ngx_http_request_t *r, ngx_chain_t *in) 394 { 395 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://BrytonLee.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Bryton's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Bryton's Blog</a></h1>
  
    <h2>Bryton Lee 的技术博客</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:BrytonLee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/10/c-macro-vs-func/">C语言宏对于调试的影响</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-10T20:51:00+08:00" pubdate data-updated="true">Feb 10<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在写一个nginx的模块，过程中遇到一个小问题，感受到了C语言宏跟函数的区别，记录下来。</p>

<h2>问题现象:</h2>

<p>先看一段相关代码</p>

<pre><code>393    ngx_http_stylecombine_body_filter(ngx_http_request_t *r, ngx_chain_t *in)   
394    {                                                                   
395     int                   rc;                                       
396     ngx_chain_t                    out;
397     ngx_http_stylecombine_ctx_t  *ctx;                                      
398                                                                        

399     ctx = ngx_http_get_module_ctx(r, ngx_http_stylecombine_filter_module);  
400                                                                     
401     if (ctx == NULL || r-&gt;header_only) {               
402         return ngx_http_next_body_filter(r, in);                    
403     } 
</code></pre>

<p>399行通过ngx_http_get_module_ctx获取ctx,401行if语句判断ctx是否为空。在调试的过程中发现402行的ngx_http_next_body_filter总是会执行到，ngx_http_stylecombine_body_filter函数提前返回。</p>

<p>很显然。要么ctx== NULL,要么就是r->header_only不为0,马上启动gdb，下断点在ngx_http_stylecombine_body_filter,运行之。程序停止在393行，单步执行到401行，通过print命令打印出变量ctx和r->header_only, 如下所示：</p>

<pre><code>(gdb) p ctx
$29 = (ngx_http_stylecombine_ctx_t *) 0x989680
(gdb) p r-&gt;header_only
$30 = 0
</code></pre>

<p>当天调试得比较晚，比较粗心没发现其中的问题。 乍看之下401行的if语句不应该为真， ctx有值，r->header_only也为0, 那为什么402行还是会被执行呢？</p>

<h2>问题分析:</h2>

<p>遇到这种问题，我常用的方法是先使用gdb的反汇编功能，然后指令级单步跟踪。(BTW：虽然我的汇编不好，马马虎虎能读反汇编后的结果)下面是ngx_http_stylecombine_body_filter反汇编片段：</p>

<pre><code>(gdb) disassemble 
Dump of assembler code for function ngx_http_stylecombine_body_filter:
0x0000000000487b8b &lt;ngx_http_stylecombine_body_filter+0&gt;:    push   %r15
0x0000000000487b8d &lt;ngx_http_stylecombine_body_filter+2&gt;:   push   %r14
0x0000000000487b8f &lt;ngx_http_stylecombine_body_filter+4&gt;:   push   %r13
0x0000000000487b91 &lt;ngx_http_stylecombine_body_filter+6&gt;:   push   %r12
0x0000000000487b93 &lt;ngx_http_stylecombine_body_filter+8&gt;:   push   %rbp
0x0000000000487b94 &lt;ngx_http_stylecombine_body_filter+9&gt;:   push   %rbx
0x0000000000487b95 &lt;ngx_http_stylecombine_body_filter+10&gt;:  sub    $0x68,%rsp
0x0000000000487b99 &lt;ngx_http_stylecombine_body_filter+14&gt;:  mov    %rdi,%r14
0x0000000000487b9c &lt;ngx_http_stylecombine_body_filter+17&gt;:  mov    %rsi,%r13
0x0000000000487b9f &lt;ngx_http_stylecombine_body_filter+20&gt;:  mov    0x10(%rdi),%rdx
0x0000000000487ba3 &lt;ngx_http_stylecombine_body_filter+24&gt;:  mov       0x234c76(%rip),%rax        # 0x6bc820 &lt;ngx_http_stylecombine_filter_module&gt;
0x0000000000487baa &lt;ngx_http_stylecombine_body_filter+31&gt;:  mov    (%rdx,%rax,8),%rax
0x0000000000487bae &lt;ngx_http_stylecombine_body_filter+35&gt;:  test   %rax,%rax
0x0000000000487bb1 &lt;ngx_http_stylecombine_body_filter+38&gt;:  je     0x487bbc &lt;ngx_http_stylecombine_body_filter+49&gt;
0x0000000000487bb3 &lt;ngx_http_stylecombine_body_filter+40&gt;:  testb  $0x2,0x468(%rdi)
0x0000000000487bba &lt;ngx_http_stylecombine_body_filter+47&gt;:  je     0x487bd0 &lt;ngx_http_stylecombine_body_filter+69&gt;
0x0000000000487bbc &lt;ngx_http_stylecombine_body_filter+49&gt;:  mov    %r13,%rsi
0x0000000000487bbf &lt;ngx_http_stylecombine_body_filter+52&gt;:  mov    %r14,%rdi
0x0000000000487bc2 &lt;ngx_http_stylecombine_body_filter+55&gt;:  callq  *0x24f140(%rip)        # 0x6d6d08 &lt;ngx_http_next_body_filter&gt;
0x0000000000487bc8 &lt;ngx_http_stylecombine_body_filter+61&gt;:  mov    %rax,%rdx
0x0000000000487bcb &lt;ngx_http_stylecombine_body_filter+64&gt;:  jmpq   0x488175 &lt;ngx_http_stylecombine_body_filter+1514&gt;
0x0000000000487bd0 &lt;ngx_http_stylecombine_body_filter+69&gt;:  mov    %rax,(%rsp)
0x0000000000487bd4 &lt;ngx_http_stylecombine_body_filter+73&gt;:  mov    0x18(%rax),%rax
0x0000000000487bd8 &lt;ngx_http_stylecombine_body_filter+77&gt;:  cmp    $0x1,%rax
0x0000000000487bdc &lt;ngx_http_stylecombine_body_filter+81&gt;:  je     0x487c49 &lt;ngx_http_stylecombine_body_filter+190&gt;
0x0000000000487bde &lt;ngx_http_stylecombine_body_filter+83&gt;:  cmp    $0x1,%rax
0x0000000000487be2 &lt;ngx_http_stylecombine_body_filter+87&gt;:  jb     0x487bfd &lt;ngx_http_stylecombine_body_filter+114&gt;
0x0000000000487be4 &lt;ngx_http_stylecombine_body_filter+89&gt;:  cmp    $0x2,%rax
0x0000000000487be8 &lt;ngx_http_stylecombine_body_filter+93&gt;:  je     0x487d71 &lt;ngx_http_stylecombine_body_filter+486&gt;
0x0000000000487bee &lt;ngx_http_stylecombine_body_filter+99&gt;:  cmp    $0x3,%rax
0x0000000000487bf2 &lt;ngx_http_stylecombine_body_filter+103&gt;: jne    0x4880c5 &lt;ngx_http_stylecombine_body_filter+1338&gt;
0x0000000000487bf8 &lt;ngx_http_stylecombine_body_filter+109&gt;: jmpq   0x4880b4 &lt;ngx_http_stylecombine_body_filter+1321&gt;
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---quit
</code></pre>

<p>地址0x0000000000487bbc &lt;ngx_http_stylecombine_body_filter+49>开始到0x0000000000487bc2 &lt;ngx_http_stylecombine_body_filter+55>之间有3条指令，前两条指令是给第3条调用指令传递的参数。x86_64的ABI规定低于6个参数的函数默认使用寄存器传参，寄存器传参顺序是rdi,rsi,rdx,rcx,r8和r9。也就是rdi是ngx_http_next_body_filter的第一个参数r, rsi是ngx_http_next_body_filter的第二个参数in。 r13,r14两个寄存器的内容来源于0x0000000000487b99和0x0000000000487b9c处的两条指令。ngx_http_stylecombine_body_filter和ngx_http_next_body_filter是一样的参数形式，回头去看0x0000000000487b99和0x0000000000487b9c处的两条指令，很容易发现ngx_http_stylecombine_body_filter函数在使用r和in之前各保存到了一份在r14和r13两个寄存器中。</p>

<p>从上面反汇编的结果可以看出，如果要执行到ngx_http_next_body_filter退出，程序的控制流必定是会流经ngx_http_stylecombine_body_filter+49处，上面反汇编的代码只有一处就是ngx_http_stylecombine_body_filter+38，而ngx_http_stylecombine_body_filter+38处的je跳转指令取决于前一条指令test   %rax,%rax对于EFLAG寄存器Z标志位的影响，如果rax为0,Z标志位为0,je指令跳转到ngx_http_stylecombine_body_filter+49。 所以只要单步执行下来到ngx_http_stylecombine_body_filter+35处看下rax的值，就能确定是否跳转。通过gdb指令单步跟踪发现rax确实为0:</p>

<pre><code>(gdb) p $rax
$28 = 0
</code></pre>

<p>这就解释了为什么ngx_http_stylecombine_body_filter为什么总是提前执行ngx_http_next_body_filter退出。问题的重点是<strong>rax代表什么?为什么会是0?</strong></p>

<h2>问题的本质:</h2>

<p>要追究问题的本质需要知道C语句</p>

<pre><code>ctx = ngx_http_get_module_ctx(r, ngx_http_stylecombine_filter_module);
</code></pre>

<p>经过gcc编译之后到底翻译成了什么？
C语言函数ngx_http_stylecombine_body_filter反汇编之后的第一条指令到ngx_http_stylecombine_body_filter+35处指令并不多，我们可以一一对照下分析下，</p>

<pre><code>0x0000000000487b8b &lt;ngx_http_stylecombine_body_filter+0&gt;:    push   %r15
0x0000000000487b8d &lt;ngx_http_stylecombine_body_filter+2&gt;:   push   %r14
0x0000000000487b8f &lt;ngx_http_stylecombine_body_filter+4&gt;:   push   %r13
0x0000000000487b91 &lt;ngx_http_stylecombine_body_filter+6&gt;:   push   %r12
0x0000000000487b93 &lt;ngx_http_stylecombine_body_filter+8&gt;:   push   %rbp
0x0000000000487b94 &lt;ngx_http_stylecombine_body_filter+9&gt;:   push   %rbx
;以上是保存寄存器的值，这些寄存器在本次函数调用中有可能被使用到，
;需要保护起来，在函数退出的时候通过pop操作恢复回去。
0x0000000000487b95 &lt;ngx_http_stylecombine_body_filter+10&gt;:  sub    $0x68,%rsp
;这条指令开辟栈上空间用于保存函数的局部变量。
;也就是对于到这三条C语句 （rc， out和ctx指针占用的字节数在比0x68要小，
;       实际上gcc会可能会对齐局部变量加快CPU对于变量的访问速度，
;       另外对于整个函数使用的局部变量都会一次性分配好，ngx_http_stylecombine_body_filter有些局部变量在后面声明。）
; 395        int                   rc;                                       
; 396        ngx_chain_t                    out;
; 397        ngx_http_stylecombine_ctx_t  *ctx; 

0x0000000000487b99 &lt;ngx_http_stylecombine_body_filter+14&gt;:  mov    %rdi,%r14
0x0000000000487b9c &lt;ngx_http_stylecombine_body_filter+17&gt;:  mov    %rsi,%r13
;前文说到，这两条指令保存r和in到r14和r13寄存器。
</code></pre>

<p>结合前面的分析，也就是剩下三条指令和一句C语句需要分析。</p>

<pre><code>0x0000000000487b9f &lt;ngx_http_stylecombine_body_filter+20&gt;:    mov    0x10(%rdi),%rdx
0x0000000000487ba3 &lt;ngx_http_stylecombine_body_filter+24&gt;:  mov    0x234c76(%rip),%rax        # 0x6bc820 &lt;ngx_http_stylecombine_filter_module&gt;
0x0000000000487baa &lt;ngx_http_stylecombine_body_filter+31&gt;:  mov    (%rdx,%rax,8),%rax;
</code></pre>

<p>很显然这三条指令是对应到ctx = ngx_http_get_module_ctx(r, ngx_http_stylecombine_filter_module);(后面可以看到这么说不全对)</p>

<p>当我调试到此处的时候，发现ngx_http_get_module_ctx其实是一个宏，这个宏的定义如下：</p>

<pre><code>#define ngx_http_get_module_ctx(r, module)  (r)-&gt;ctx[module.ctx_index]
</code></pre>

<p>了解C语言的同学一定知道ctx是r的一个成员，对于汇编来说其实就是一个地址，</p>

<pre><code>mov    0x10(%rdi),%rdx   
;rdi寄存器保存的是r的地址，0x10(%rdi)表示r的地址开始加16(0x10)
;由此可知ctx成员在r结构体中的偏移是16.
</code></pre>

<p> module.ctx_index用于在ctx中做索引，通过ngx_module_t的定义，我们知道ctx_index是ngx_module_t的首成员，</p>

<pre><code>struct ngx_module_s {
ngx_uint_t            ctx_index;
ngx_uint_t            index;
.....
</code></pre>

<p>所以module和module.ctx_index的地址是相同的，这也是为什么gdb提示的是# 0x6bc820 &lt;ngx_http_stylecombine_filter_module></p>

<pre><code>mov    0x234c76(%rip),%rax        # 0x6bc820 &lt;ngx_http_stylecombine_filter_module&gt;
</code></pre>

<p>有了r->ctx的地址(保存在rdx)，和索引值module.ctx_index(保存在rax)，接下来就是去取索引的内容：</p>

<pre><code>mov    (%rdx,%rax,8),%rax
;rdx + rax * 8
;x86_64的地址长度为8个字节。
</code></pre>

<p>到此为止知道ngx_http_stylecombine_body_filter+35指令之前rax寄存器保存内容的来历。就是说(r)&ndash;>ctx[module.ctx_index]确实是为0, if语句的跳转没有出错。</p>

<p>等等，貌似少了什么东西，<strong>为什么在前面通过gdb打印ctx的值不为0，按照C语言的语句ctx = ngx_http_get_module_ctx(r, ngx_http_stylecombine_filter_module);ctx应该要是0才对!?</strong> 我认为这是由于gcc对C语言的宏进行展开之后，通过数据流分析和优化能发现if语句里面要判断的值其实是(r)&ndash;>ctx[module.ctx_index],不是局部变量ctx，从反汇编的结果也可以看出在ngx_http_stylecombine_body_filter+35处的test语句之前并没有ctx的赋值操作,如果ngx_http_get_module_ctx是一个函数而不是一个宏，ctx应该会是0(前提是编译器没有过度优化)。</p>

<p>这就能解释ctx为什么不为0,gdb打印出来ctx的值实际上是一个未初始化的栈上的值，也就是一个野值(0x989680)，当天调试较晚困了没有发现。同时也解释了我前面说从ngx_http_stylecombine_body_filter+20开始的三条mov指令对应到ctx = ngx_http_get_module_ctx(r, ngx_http_stylecombine_filter_module)的说法其实是不全对的，因为ctx的赋值操作没有在这3条指令中。(<em>ps:欢迎大家和我交流^&ndash;^</em>)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/27/keepalive/">再谈KeepAlive</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-27T14:19:00+08:00" pubdate data-updated="true">Dec 27<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>我为什么要再谈KeepAlive</h2>

<p>申请的域名到现在，除了一篇开篇博文到目前为止还没有一篇正式的文章。最近工作中遇到一个问题，想把它记录下来，场景是这样的：</p>

<p><img src="/images/nginx-lvs-client.jpg" title="nginx-lvs-client" alt="nginx-lvs-client" /></p>

<p>从上图可以看出，用户通过Client访问的是LVS的VIP， VIP后端挂载的RealServer是Nginx服务器。 Client可以是浏览器也可以是一个客户端程序。一般情况下， 这种架构不会出现问题，但是如果Client端把请求发送给Nginx，Nginx的后端需要一段时间才能返回结果，超过1分30秒就会有问题，使用LVS作为负载均衡设备看到的现象就是1分30秒之后， Client和Nginx链接被断开，没有数据返回。 原因是LVS默认保持TCP的Session为90s，超过90s没有TCP报文在链接上传输，LVS就会给两端发送REST报文断开链接。LVS这么做的原因相信大家都知道一二，我所知道的原因主要有两点：</p>

<pre><code>1.节省负载均衡设备资源，每一个TCP/UDP的链接都会在负载均衡设备上创建一个Session的结构，
  链接如果一直不断开，这种Session结构信息最终会消耗掉所有的资源，所以必须释放掉。
2.另外释放掉能保护后端的资源，如果攻击者通过空链接，链接到Nginx上，如果Nginx没有做合适
  的保护，Nginx会因为链接数过多而无法提供服务。
</code></pre>

<p>这种问题不只是在LVS上有，之前在商用负载均衡设备F5上遇到过同样的问题，F5的Session断开方式和LVS有点区别，F5不会主动发送REST给链接的两端，Session消失之后，当链接中一方再次发送报文时会接收到F5的REST, 之后的现象是再次发送报文的一端TCP链接状态已经断开，而另外一端却还是ESTABLISH状态。</p>

<p>知道是负载均衡设备原因之后，第一反应就是通过开启KeepAlive来解决。到此这个问题应该是结束了，但是我发现过一段时间总又有人提起KeepAlive的问题，甚至发现由于KeepAlive的理解不正确浪费了很多资源，原本能使用LVS的应用放在了公网下沉区，或者换成了商用F5设备(F5设备的Session断开时间要长一点，默认应该是5分钟)。所以我决定把我知道的KeepAlive知识点写篇博客分享出来。</p>

<h2>为什么要有KeepAlive？</h2>

<p>在谈KeepAlive之前，我们先来了解下简单TCP知识(知识很简单，高手直接忽略)。首先要明确的是在TCP层是没有“请求”一说的，经常听到在TCP层发送一个请求，这种说法是错误的。TCP是一种通信的方式，“请求”一词是事务上的概念，HTTP协议是一种事务协议，如果说发送一个HTTP请求，这种说法就没有问题。也经常听到面试官反馈有些面试运维的同学，基本的TCP三次握手的概念不清楚， 面试官问TCP是如何建立链接，面试者上来就说，假如我是客服端我发送一个请求给服务端，服务端发送一个请求给我。。。这种一听就知道对TCP基本概念不清楚。下面是我通过wireshark抓取的一个TCP建立握手的过程。（命令行基本上用TCPdump,后面我们还会用这张图说明问题）:</p>

<p><img src="/images/tcp-session-create.jpg" title="tcp-session-create" alt="tcp-session-create" /></p>

<p>现在我看只要看前3行，这就是TCP三次握手的完整建立过程，第一个报文SYN从发起方发出，第二个报文SYN,ACK是从被连接方发出，第三个报文ACK确认对方的SYN，ACK已经收到，如下图：</p>

<p><img src="/images/tcp_syn_synack_ack.jpg" title="tcp-syn-synack-ack" alt="tcp-syn-synack-ack" /></p>

<p>但是数据实际上并没有传输，请求是有数据的，第四个报文才是数据传输开始的过程，细心的读者应该能够发现wireshark把第四个报文解析成HTTP协议，HTTP协议的GET方法和URI也解析出来，所以说TCP层是没有请求的概念，HTTP协议是事务性协议才有请求的概念，TCP报文承载HTTP协议的请求(Request)和响应(Response)。</p>

<p>现在才是开始说明为什么要有KeepAlive。 链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p>

<h2>如何开启KeepAlive</h2>

<p>KeepAlive并不是默认开启的，在Linux系统上没有一个全局的选项去开启TCP的KeepAlive。需要开启KeepAlive的应用必须在TCP的socket中单独开启。Linux Kernel有三个选项影响到KeepAlive的行为：</p>

<pre><code>1.net.ipv4.tcp_keepalive_intvl = 75
2.net.ipv4.tcp_keepalive_probes = 9
3.net.ipv4.tcp_keepalive_time = 7200
</code></pre>

<p>tcp_keepalive_time的单位是秒，表示TCP链接在多少秒之后没有数据报文传输启动探测报文; tcp_keepalive_intvl单位是也秒,表示前一个探测报文和后一个探测报文之间的时间间隔，tcp_keepalive_probes表示探测的次数。</p>

<p>TCP socket也有三个选项和内核对应，通过setsockopt系统调用针对单独的socket进行设置：</p>

<pre><code>TCP_KEEPCNT: 覆盖 tcp_keepalive_probes
TCP_KEEPIDLE: 覆盖  tcp_keepalive_time
TCP_KEEPINTVL: 覆盖  tcp_keepalive_intvl
</code></pre>

<p>举个例子，以我的系统默认设置为例，kernel默认设置的tcp_keepalive_time是7200s, 如果我在应用程序中针对socket开启了KeepAlive,然后设置的TCP_KEEPIDLE为60，那么TCP协议栈在发现TCP链接空闲了60s没有数据传输的时候就会发送第一个探测报文。</p>

<h2>TCP KeepAlive和HTTP的Keep-Alive是一样的吗？</h2>

<p>估计很多人乍看下这个问题才发现其实经常说的KeepAlive不是这么回事，实际上在没有特指是TCP还是HTTP层的KeepAlive，不能混为一谈。TCP的KeepAlive和HTTP的Keep-Alive是完全不同的概念。TCP层的KeepAlive上面已经解释过了。 HTTP层的Keep-Alive是什么概念呢？ 在讲述TCP链接建立的时候，我画了一张三次握手的示意图，TCP在建立链接之后， HTTP协议使用TCP传输HTTP协议的请求(Request)和响应(Response)数据，一次完整的HTTP事务如下图：</p>

<p><img src="/images/http-session.jpg" title="http-session" alt="http" /></p>

<p>各位看官请注意，这张图我简化了HTTP(Req)和HTTP(Resp)，实际上的请求和响应需要多个TCP报文。从图中可以发现一个完整的HTTP事务，有链接的建立， 请求的发送，响应接收，断开链接这四个过程,早期通过HTTP协议传输的数据以文本为主，一个请求可能就把所有要返回的数据取到，但是，现在要展现一张完整的页面需要很多个请求才能完成，如图片,JS,CSS等，如果每一个HTTP请求都需要新建并断开一个TCP，这个开销是完全没有必要的，开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，通常浏览器在第一个请求返回之后会立即发送第二个请求，如果某一时刻只能有一个链接，同一个TCP链接处理的请求越多，开启KeepAlive能节省的TCP建立和关闭的消耗就越多。当然通常会启用多个链接去从服务器器上请求资源，但是开启了Keep-Alive之后，仍然能加快资源的加载速度。HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项。当设置为Connection:keep-alive表示开启，设置为Connection:close表示关闭。实际上HTTP的KeepAlive写法是Keep-Alive，跟TCP的KeepAlive写法上也有不同。 所以TCP KeepAlive和HTTP的Keep-Alive不是同一回事情。</p>

<h2>Nginx的TCP KeepAlive如何设置</h2>

<p>开篇提到我最近遇到的问题，Client发送一个请求到Nginx服务端，服务端需要经过一段时间的计算才会返回， 时间超过了LVS Session保持的90s,在服务端使用Tcpdump抓包,本地通过wireshark分析显示的结果如第二副图所示，第5条报文和最后一条报文之间的时间戳大概差了90s。在确定是LVS的Session保持时间到期的问题之后，我开始在寻找Nginx的TCP KeepAlive如何设置，最先找到的选项是keepalive_timeout,从同事那里得知keepalive_timeout的用法是当keepalive_timeout的值为0时表示关闭keepalive,当keepalive_timeout的值为一个正整数值时表示链接保持多少秒，于是把keepalive_timeout设置成75s,但是实际的测试结果表明并不生效。显然keepalive_timeout不能解决TCP层面的KeepAlive问题，实际上Nginx涉及到keepalive的选项还不少，Nginx通常的使用方式如下：</p>

<p><img src="/images/nginx.jpg" title="nginx" alt="nginx" /></p>

<p>从TCP层面Nginx不仅要和Client关心KeepAlive,而且还要和Upstream关心KeepAlive, 同时从HTTP协议层面，Nginx需要和Client关心Keep-Alive,如果Upstream使用的HTTP协议，还要关心和Upstream的Keep-Alive，总而言之，还比较复杂。所以搞清楚TCP层的KeepAlive和HTTP的Keep-Alive之后，就不会对于Nginx的KeepAlive设置错。我当时解决这个问题时候不确定Nginx有配置TCP keepAlive的选项，于是我打开Ngnix的源代码，在源代码里面搜索TCP_KEEPIDLE,相关的代码如下：</p>

<pre><code> 519 #if (NGX_HAVE_KEEPALIVE_TUNABLE)
 520                 
 521         if (ls[i].keepidle) { 
 522             if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_KEEPIDLE,
 523                            (const void *) &amp;ls[i].keepidle, sizeof(int))
 524                 == -1)
 525             {
 526                 ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_socket_errno,
 527                               "setsockopt(TCP_KEEPIDLE, %d) %V failed, ignored",
 528                               ls[i].keepidle, &amp;ls[i].addr_text);
 529             }
 530         }
</code></pre>

<p>从代码的上下文我发现TCP KeepAlive可以配置，所以我接着查找通过哪个选项配置，最后发现listen指令的so_keepalive选项能对TCP socket进行KeepAlive的配置。</p>

<pre><code>so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]
on表示开启
off表示关闭
有些系统提供跟精确的控制，比如linux:
    keepidle表示等待时间，keepintvl表示探测报的发送间隔，keepcnt表示探测报文发送的次数。
</code></pre>

<p>以上三个参数只能使用一个，不能同时使用， 比如so_keepalive=on, so_keepalive=off或者so_keepalive=30s::(表示等待30s没有数据报文发送探测报文)。通过设置listen 80,so_keepalive=60s::之后成功解决Nginx在LVS保持长链接的问题，避免了使用其他高成本的方案。在商用负载设备上如果遇到类似的问题同样也可以通过这种方式解决。</p>

<h2>参考资料</h2>

<p>《TCP/IP协议详解VOL1》&mdash;强烈建议对于网络基本知识不清楚同学有空去看下。</p>

<p><a href="http://tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/#overview">http://tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/#overview</a></p>

<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">http://nginx.org/en/docs/http/ngx_http_core_module.html</a></p>

<p>Nginx Source code: <a href="https://github.com/alibaba/tengine">https://github.com/alibaba/tengine</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/02/first-post/">记录技术点滴，积累铸就高度</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-02T16:17:00+08:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>记录技术点滴</h2>

<p>很多时候想把自己在平常工作，学习中碰到的技术，遇到的难题，总结的解决方案写下来。在我的环境当中，我算是比较喜欢分享的，分享到自己都感觉到不好意思，可能是技术不够严谨，也可能是技术的分享确实乏味，有些可能跟工作没有直接关系。所以没能继续，总结得也不够多。我看到很多技术上很好的人他们乐于分享，无论是中国的还是外国的。不奢望我总结的内容能够有他们的高度，能有多少的读者，但是我还是希望能把自己的一些总结或者心得写下来，哪怕自己查阅也好。</p>

<h2>积累铸就高度</h2>

<p>每天上班下班，每天看书学习，也没看到自己的技术又多大的进步。我觉得其实技术和人的性格有类似性，虽然都是从事的IT行业，各个人的技术特长还是不一样的。虽然我知道自己的技术不怎么样，但是从我做过的技术分享来看，有些挺不错的效果。有时分享的内容可能就是听众百思不得其解的一个问题，有时分享的内容，尽管不是很严谨，内容也比较虚，但还是有听众会觉得不错。更好的是分享能促进自己对于问题的理解,交到志同道合的朋友！这是我觉得有必要开博的重要原因。</p>

<h2>对本博客的要求</h2>

<p>我自己其实也在其他好的网站上申请过博客空间，写过一两篇文章，但是都没有坚持下来，久而久之也不知道自己有几个博客。挺遗憾的。这次重新开始，没有选择在其他网站的blog上继续，一来是同事手上刚好有一台机器资源，尽管现在还没有确定能不能完全长期使用，所以为了保证博客的可用性，我先在github上做。然后花了一点时间在godaddy.net上申请了一个两年的域名，花了差不多170元RMB。有人说花钱的东西会心痛，会心痛就能坚持，希望如此。</p>

<p>这次对自己的要求是在这两年的域名有效期坚持写不少于8篇技术性的文章。加油！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/02/10/c-macro-vs-func/">C语言宏对于调试的影响</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/27/keepalive/">再谈KeepAlive</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/02/first-post/">记录技术点滴，积累铸就高度</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/brytonlee">@brytonlee</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'brytonlee',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Bryton Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
